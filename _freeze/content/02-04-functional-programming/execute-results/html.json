{
  "hash": "f215fa9f9494e6a916b0de8fff152414",
  "result": {
    "markdown": "# Programming Paradigms #\n\n## Reading ##\n\n- Introductions to parts II and III of @WickhamAdvanced2014\n- @ChambersObjectOrientedProgrammingFunctional2014\n\n## Dependencies ##\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('sloop')\n```\n:::\n\n\n## Programming paradigms ##\nProcedural or imperative\n: Software is a series of instructions (\"procedures\"), which the computer carries out in order.  Special instructions (if-then, loops) are used to change the order based on inputs or other conditions.  \n    - Examples: FORTRAN, BASIC, C, a calculator\n\nObject-oriented\n: Software is made up of objects, which have properties (\"attributes,\" including other objects) and do things (\"methods\").  \n    - Examples: Python, Java\n\nFunctional\n: Software is made up of functions, which are run sequentially on the inputs.  \n    - Examples: Lisp, Haskell\n\n### R is both object-oriented *and* functional ###\n\n- Object-oriented:  Everything that exists is an object\n- Functional:  Everything that happens is a function call\n    \n## Object-oriented programming\n\n- board game as OOP\n- regression models as OOP\n\n## The OOP you're used to ##\n\n- Classes are defined by their elements and methods\n- Changing/adding elements and methods requires changing the class definition\n- For $x$ to be an $F$, $x$ must be created as an $F$\n\n\n::: {.cell}\n\n```{.python .cell-code}\n## <https://vegibit.com/python-class-examples/>\nclass Vehicle:\n    def __init__(self, brand, model, type):\n        self.brand = brand\n        self.model = model\n        self.type = type\n        self.gas_tank_size = 14\n        self.fuel_level = 0\n\n    def fuel_up(self):\n        self.fuel_level = self.gas_tank_size\n        print('Gas tank is now full.')\n\n    def drive(self):\n        if self.fuel_level > 0:\n            print(f'The {self.model} is now driving.')\n            self.fuel_level -= 1\n        else:\n            print(f'The {self.model} is out of gas!')\n\ndhCar = Vehicle('Honda', 'Fit', 'Hatchback')\ndhCar.gas_tank_size = 10\ndhCar.fuel_up()\ndhCar.drive()\n```\n:::\n\n---\n\n## S3 is OOP, but weird\n\n- S3 classes can be changed on the fly, with no attempt to validate any assumptions. \n\n::: {.cell}\n\n```{.r .cell-code}\ndh_car = list(brand = 'Honda', model = 'Fit', type = 'Hatchback')\nclass(dh_car)\nclass(dh_car) = c('vehicle', class(dh_car))\nclass(dh_car)\ninherits(dh_car, 'vehicle')\n```\n:::\n::: {.cell}\n\n```{.r .cell-code}\nmodel = lm(log(mpg) ~ log(disp), data = mtcars)\nclass(model)\nprint(model)\nclass(model) = 'Date'\nclass(model)\ntry(print(model))\n```\n:::\n\n- Wickham discusses good practices to reduce this chaos in S3\n    - write constructor, validator, and helper functions\n- S4 and R6 provide more conventional OOP structure\n\n---\n\n\n- S3 uses **generic functions**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreg_model = lm(log(mpg) ~ log(disp), data = mtcars)\naov_model = aov(log(mpg) ~ log(disp), data = mtcars)\n\nclass(reg_model)\nclass(aov_model)\ninherits(aov_model, 'lm')\n\nprint(reg_model)\nprint(aov_model)\n\nresiduals(aov_model)\nresiduals(reg_model)\n```\n:::\n\n\n- Both `aov_model` and `reg_model` inherit from `lm`\n- `print()` and `residuals()` are both generics\n    - (There can be) different versions of each function for different classes\n    - Different output for `print()`\n    - Same output for `residuals()`\n\n\n---\n\n- `print()` is a generic; the call just passes us off using `UseMethod()`\n\n::: {.cell}\n\n```{.r .cell-code}\nprint\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nUseMethod(\"print\")\n<bytecode: 0x7f857ed74a10>\n<environment: namespace:base>\n```\n:::\n:::\n\n- `sloop` package is useful for understanding how S3 figures out which specific function to call\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sloop)\n```\n:::\n::: {.cell}\n\n```{.r .cell-code}\ns3_dispatch(print(reg_model))\ns3_dispatch(print(aov_model))\n```\n:::\n\n- Note that the class-specific functions are often hidden\n::: {.cell}\n\n```{.r .cell-code}\ntry(print.lm)\ns3_get_method(print.lm)\n# stats:::print.lm\ns3_get_method(print.aov)\n# stats:::print.aov\n```\n:::\n\n- *Use `s3_dispatch()` to explain why the two models have the same output for `residuals()`.*\n\n---\n\n\n- `sloop::s3_methods_generic()` lists all class-specific versions of generics\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns3_methods_generic('print')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 253 × 4\n   generic class   visible source             \n   <chr>   <chr>   <lgl>   <chr>              \n 1 print   acf     FALSE   registered S3method\n 2 print   AES     FALSE   registered S3method\n 3 print   anova   FALSE   registered S3method\n 4 print   aov     FALSE   registered S3method\n 5 print   aovlist FALSE   registered S3method\n 6 print   ar      FALSE   registered S3method\n 7 print   Arima   FALSE   registered S3method\n 8 print   arima0  FALSE   registered S3method\n 9 print   AsIs    TRUE    base               \n10 print   aspell  FALSE   registered S3method\n# … with 243 more rows\n```\n:::\n:::\n\n\n- And similarly for all generics defined for a given class\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns3_methods_class('lm')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 35 × 4\n   generic        class visible source             \n   <chr>          <chr> <lgl>   <chr>              \n 1 add1           lm    FALSE   registered S3method\n 2 alias          lm    FALSE   registered S3method\n 3 anova          lm    FALSE   registered S3method\n 4 case.names     lm    FALSE   registered S3method\n 5 confint        lm    TRUE    stats              \n 6 cooks.distance lm    FALSE   registered S3method\n 7 deviance       lm    FALSE   registered S3method\n 8 dfbeta         lm    FALSE   registered S3method\n 9 dfbetas        lm    FALSE   registered S3method\n10 drop1          lm    FALSE   registered S3method\n# … with 25 more rows\n```\n:::\n:::\n\n\n## Functional programming\n\n- board game as a series of functions? \n- regression models as a series of functions\n\n## Common features of functional programming\n\nFirst-class functions\n:  Functions can be used like any other data type, including as inputs to and outputs from other functions\n\nDeterminism\n:  Given a list of input values, a function always returns the same output value\n\nNo side effects\n:  A function doesn't have any effects other than returning its output\n\nImmutability\n:  Once a variable is assigned a value, that value cannot be changed\n\nThese features make it much easier to reason about how a functional program works. \n\n\n## Breaking R: Everything that happens is a function ##\n\n- This includes assignment\n\n```\nfoo = 3\n`<-` <- function(x, y) x + y\nfoo <- 5\nfoo = 7\n```\n\n- And brackets\n\n```\n`[` <- function(x, y) x * y\nbar = data.frame(x = rep(1, 15),\n                 y = rep(2, 15))\nbar['x']\nbar[2]\nbar[18]\n```\n\n## Actually-useful functional R:  Pipes (and the tidyverse)\n\n- Pipe syntax for function composition (`%>%` and `|>`)\n- Tidyverse functions are designed to work with pipes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n    filter(cyl > 4) %>% \n    lm(mpg ~ disp, data = .) %>% \n    summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = mpg ~ disp, data = .)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.4010 -1.5419 -0.5121  1.1408  4.9873 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 23.623520   1.463181  16.145 1.50e-12 ***\ndisp        -0.023527   0.004682  -5.025 7.52e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.118 on 19 degrees of freedom\nMultiple R-squared:  0.5706,\tAdjusted R-squared:  0.548 \nF-statistic: 25.25 on 1 and 19 DF,  p-value: 7.521e-05\n```\n:::\n:::\n\n\n- Using the new native pipes with the new native anonymous functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n    filter(cyl > 4) |>\n    {\\(d) lm(mpg ~ disp, data = d)}() |>\n    summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = mpg ~ disp, data = d)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.4010 -1.5419 -0.5121  1.1408  4.9873 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 23.623520   1.463181  16.145 1.50e-12 ***\ndisp        -0.023527   0.004682  -5.025 7.52e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.118 on 19 degrees of freedom\nMultiple R-squared:  0.5706,\tAdjusted R-squared:  0.548 \nF-statistic: 25.25 on 1 and 19 DF,  p-value: 7.521e-05\n```\n:::\n:::\n\n\n## Programming paradigms and data science\n\n- OOP is most useful for developers\n- Functional programming rules are really useful for data cleaning and analysis\n    - \"The analysis pipeline\"\n    - Reasoning about the state of our code\n    - Ensuring reproducibility\n\n\n<!--\n## Lab:  Purrr\n- palmerpenguins\n- broom\n- map() and list columns in dataframes\n- microethics? \n-->\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}