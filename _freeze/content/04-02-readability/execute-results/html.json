{
  "hash": "f5f3f3b6fb69c72e2e2a3a6a97fb411b",
  "result": {
    "markdown": "# Readable code is reliable code \n\n## Reading \n\n- @BryanCodeSmellsFeels2018\n- @PostolovskiYourCodeReview2020\n- @BuckensSelfdocumentingMythHow2019\n\n\n## Writing code is writing\n\n- Multiple audiences\n    - Collaborators\n    - (Some) reviewers and readers of the paper\n    - Peers who want to analyze and extend your methods\n    - *Yourself in six months*\n\n> Any code of your own that you haven't looked at for six or more months might as well have been written by someone else. (\"Eagleson's Law\")\n\n- Your code is *readable* to the extent that people can use it to easily and reliably \n    - predict, \n    - diagnose, and\n    - extend your code\n\n\n## Code style ##\n\n- iNéwritteNélanguagEáconventionSéfoRîpunctuatioNøcapitalizatioNîaiDécompr\\\n  ehensioNébYéindicatinGéstructurE\n    - this is what it's like to read poorly-styled code\n    - conventions only work if they're *shared* conventions\n\n- Style guides provide shared conventions for readable code\n    - In-line spacing makes it easier to pick out distinguish functions, operators, and variables in a line\n    - Returns distinguish arguments in a function call\n    - Indentation corresponds to structure of complex expressions\n    - Common conventions for naming, assignment reduce cognitive load\n\n- Tidyverse style guide:  <https://style.tidyverse.org/>\n\n\n## Highlights from the Tidyverse style guide ##\n\n- Place all `package()` calls at the top of the script\n- Limit your code to 80 characters per line\n- Use at least 4 spaces for indenting multiline expression\n    - Control-I in RStudio will do automagic indenting\n- In multiline function calls, 1 argument = 1 line\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_function_name <- function(a = \"a long argument\",\n                               b = \"another argument\",\n                               c = \"another long argument\") {\n  # As usual code is indented by two spaces.\n}\n```\n:::\n\n\n## Using comments to explain why and indicate structure {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloading_table = function(model, \n                         threshold = .3, \n                         quiet = FALSE, \n                         path = NULL, \n                         overwrite = FALSE) {\n    loadings_unfltd = model |> \n        ## Extract loadings and tidy\n        loadings() |> \n        unclass() |> \n        as_tibble(rownames = 'item') |> \n        ## loadings() returns a wide item x factor matrix\n        pivot_longer(-item, names_to = 'factor', values_to = 'loading')\n        ## Will filter based on `threshold` below\n    \n    ## Dropped items\n    if (!quiet) {\n        loadings_df = filter(loadings_unfltd, abs(loading) > threshold)\n        dropped_df = loadings_unfltd |> \n            pivot_wider(names_from = 'factor', values_from = 'loading') |> \n            anti_join(pivot_wider(loadings_df, \n                                  names_from = 'factor', \n                                  values_from = 'loading'), \n                      by = 'item')\n        message('Dropped items')\n        print(dropped_df)\n    }\n    \n    ## Cross-loaded items\n    if (!quiet) {\n        xload_df = loadings_df |>\n            add_count(item) |>\n            filter(n > 1) |>\n            select(-n) |>\n            pivot_wider(names_from = 'factor', values_from = 'loading')\n        message('Cross-loaded items')\n        print(xload_df)\n    }\n    \n    loadings_clean = loadings_df |>\n        anti_join(xload_df, by = 'item') |>\n        ## Spread back out to item x factor for presentation\n        pivot_wider(names_from = 'factor', values_from = 'loading') |>\n        arrange(across(starts_with('MR'), desc)) |> \n        left_join(vis_labels, by = c('item' = 'tag')) |> \n        select(-item.y)\n    \n    if (!is.null(path)) {\n        if (!file.exists(path) || overwrite) {\n            write_csv(loadings_clean, path, na = '')\n        }\n        if (file.exists(path) && !overwrite) {\n            warning('CSV already exists; skipping overwrite')\n        }\n    }\n    \n    return(loadings_clean)\n}\n```\n:::\n\n\n\n## Spaces: Let your code  b r e a t h e\n\n- Always put spaces after commas, and never before (like English)\n- But not between a function name and the parentheses (like math)\n- And surrounding infix operators (`==`, `+`, `-`, `<-`, `=`)\n- Pipes `%>%` `|>` should have a space before and be at the end of the line\n\n\n## Code blocks\nWhen you put a block of code in curly braces `{}`: \n\n- `{` should be the last character on a line\n- `}` should be the first character on the line\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (y == 0) {\n  if (x > 0) {\n    log(x)\n  } else {\n    message(\"x is negative or zero\")\n  }\n} else {\n  y^x\n}\n```\n:::\n\n\n\n## Boolean variables vs. control flow\n\n- Functions that return vectors: \n    - `&`, `|`, `==`, `ifelse()`, `dplyr::if_else()`\n- Functions that return a single value: \n    - `&&`, `||`, `identical`\n- `if (x) a else b` only looks at the first (hopefully single) value of `x`\n\n## References\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    function fireSlideChanged(previousSlide, currentSlide) {\n\n      // dispatch for htmlwidgets\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for reveal\n    if (window.Reveal) {\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\n        fireSlideChanged(event.previousSlide, event.currentSlide);\n      });\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}