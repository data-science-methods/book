{
  "hash": "bb02c9956c1b1e76156734a751a37cef",
  "result": {
    "markdown": "# Functions and functional programming\n\n## Reading\n\n- @SpringateFunctionalProgramming2013\n\n## Programming paradigms\n\n- Conceptual frameworks for software engineering\n- Ways of understanding how a piece of software works\n- Ways of writing a piece of software\n\n--- \n\nProcedural or imperative\n: Software is a series of instructions (\"procedures\"), which the computer carries out in order.  Special instructions (if-then, loops) are used to change the order based on inputs or other conditions.  \n    - Examples: FORTRAN, BASIC, C, a calculator\n\nObject-oriented\n: Software is made up of objects, which have properties (\"attributes,\" including other objects) and do things (\"methods\").  \n    - Examples: Python, Java\n\nFunctional\n: Software is made up of functions, which are run sequentially on the inputs.  \n    - Examples: Lisp, Haskell\n    \n## R is both object-oriented *and* functional ##\n\n- But the object-oriented side is ... idiosyncratic [@ChambersObjectOrientedProgrammingFunctional2014]\n\n## Functional programming\n\n\"Software is made up of functions, which are run sequentially on the inputs.\"\n\n\n```{mermaid}\n%%| echo: false\n%%| fig-cap: \"A regression model as a series of functions\"\nflowchart LR\n  pre1[\" \"] -- data --> extract[extract\\nDV & IV]\n  pre2[\" \"] -- specification --> extract\n  extract -- X --> QR[QR\\ndecomposition] -- \"Q, R\" --> combine\n  extract -- Y --> combine\n  combine -- \"Rβ = Q<sup>T</sup>Y\" --> backsolve\n  backsolve -- β --> post[\" \"]\n  style pre1 height:0px;\n  style pre2 height:0px;\n  style post height:0px;\n```\n\n\n\n## Writing functions in R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Standard syntax\nnormalize <- function(x) {\n    z = (x - mean(x)) / sd(x)\n    return(z)\n}\n\n## Lambda syntax (R >= 4.1.0)\nnormalize <- \\(x){(x - mean(x)) / sd(x)}\n```\n:::\n\n\\\n\n::: {.fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\nnormalize(mtcars$mpg)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0.15088482  0.15088482  0.44954345  0.21725341 -0.23073453 -0.33028740\n [7] -0.96078893  0.71501778  0.44954345 -0.14777380 -0.38006384 -0.61235388\n[13] -0.46302456 -0.81145962 -1.60788262 -1.60788262 -0.89442035  2.04238943\n[19]  1.71054652  2.29127162  0.23384555 -0.76168319 -0.81145962 -1.12671039\n[25] -0.14777380  1.19619000  0.98049211  1.71054652 -0.71190675 -0.06481307\n[31] -0.84464392  0.21725341\n```\n:::\n:::\n\n:::\n\n## Some terminology\n\narguments\n ~ The inputs to the function, the things inside the parentheses\n\ncalling a function\n ~ `normalize` is the function itself, as an object. `normalize(mtcars$mpg)` calls or applies the function to the argument `mtcars$mpg`\n\npassing\n ~ The relationship between arguments in the call and the function's internal variables.  In `normalize(mtcars$mpg)`, `mtcars$mpg` is passed to `x`.  \n\nreturn\n ~ The output of the function. Either (a) the argument passed to `return` or (b) the value of the last line of the function. \n\n\n\n## Features of functional programming\n\nfirst-class functions\n:  Functions can be used like any other data type, including as inputs to and outputs from other functions (functionals; function factories)\n\ndeterminism\n:  Given the same input values, the function always returns the same output value\n\nno side effects\n:  The function doesn't have any effects other than returning its output\n\nimmutability\n:  Once a variable is assigned a value, that value cannot be changed\n\n\\\n\n- Functional programming implements software as strict input-output flow\n- R doesn't enforce determinism, no side effects, or immutability\n- But writing your own code around them makes it easier to reason about how your code works\n\n## References\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}