{
  "hash": "4a64d2b972f552e99d29758cf49c8fbf",
  "result": {
    "markdown": "# Programming Paradigms \n\n## Reading ##\n\n- Introductions to parts II and III of @WickhamAdvanced2014\n- @ChambersObjectOrientedProgrammingFunctional2014\n\n## Dependencies ##\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('sloop')\n```\n:::\n\n\n## Programming paradigms ##\nProcedural or imperative\n: Software is a series of instructions (\"procedures\"), which the computer carries out in order.  Special instructions (if-then, loops) are used to change the order based on inputs or other conditions.  \n    - Examples: FORTRAN, BASIC, C, a calculator\n\nObject-oriented\n: Software is made up of objects, which have properties (\"attributes,\" including other objects) and do things (\"methods\").  \n    - Examples: Python, Java\n\nFunctional\n: Software is made up of functions, which are run sequentially on the inputs.  \n    - Examples: Lisp, Haskell\n\n### R is both object-oriented *and* functional ###\n\n- Object-oriented:  Everything that exists is an object\n- Functional:  Everything that happens is a function call\n    \n## Object-oriented programming\n\n- board game as OOP\n- regression models as OOP\n\n## The OOP you're used to ##\n\n- Classes are defined by their elements and methods\n- Changing/adding elements and methods requires changing the class definition\n- For $x$ to be an $F$, $x$ must be created as an $F$\n\n\n::: {.cell}\n\n```{.python .cell-code}\n## <https://vegibit.com/python-class-examples/>\nclass Vehicle:\n    def __init__(self, brand, model, type):\n        self.brand = brand\n        self.model = model\n        self.type = type\n        self.gas_tank_size = 14\n        self.fuel_level = 0\n    \n    def fuel_up(self):\n        self.fuel_level = self.gas_tank_size\n        print('Gas tank is now full.')\n    \n    def drive(self):\n        if self.fuel_level > 0:\n            print(f'The {self.model} is now driving.')\n            self.fuel_level -= 1\n        else:\n            print(f'The {self.model} is out of gas!')\n\ndhCar = Vehicle('Honda', 'Fit', 'Hatchback')\ndhCar.gas_tank_size = 10\ndhCar.fuel_up()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGas tank is now full.\n```\n:::\n\n```{.python .cell-code}\ndhCar.fuel_level\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n```\n:::\n\n```{.python .cell-code}\ndhCar.drive()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe Fit is now driving.\n```\n:::\n\n```{.python .cell-code}\ndhCar.fuel_level\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n9\n```\n:::\n:::\n\n\n## S3 is OOP, but weird\n\n- S3 classes can be changed on the fly, with no attempt to validate any assumptions. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndh_car = list(brand = 'Honda', model = 'Fit', type = 'Hatchback')\nclass(dh_car)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nclass(dh_car) = c('vehicle', class(dh_car))\nclass(dh_car)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"vehicle\" \"list\"   \n```\n:::\n\n```{.r .cell-code}\ninherits(dh_car, 'vehicle')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nnotamodel = list()\nnotamodel$residuals = 1:10\nclass(notamodel) = 'lm'\nresiduals(notamodel)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\nprint(notamodel)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nNULL\n\nNo coefficients\n```\n:::\n:::\n\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel = lm(log(mpg) ~ log(disp), data = mtcars)\nclass(model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"lm\"\n```\n:::\n\n```{.r .cell-code}\nprint(model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = log(mpg) ~ log(disp), data = mtcars)\n\nCoefficients:\n(Intercept)    log(disp)  \n     5.3810      -0.4586  \n```\n:::\n\n```{.r .cell-code}\nclass(model) = 'Date'\nclass(model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Date\"\n```\n:::\n\n```{.r .cell-code}\ntry(print(model))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in as.POSIXlt.Date(x) : \n  'list' object cannot be coerced to type 'double'\n```\n:::\n:::\n\n---\n\n- Wickham discusses good practices to reduce this chaos in S3\n    - write constructor, validator, and helper functions\n- S4 and R6 provide more conventional OOP structure\n\n## Models as objects\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel = lm(mpg ~ disp, data = mtcars)\nstr(model, give.attr = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 12\n $ coefficients : Named num [1:2] 29.5999 -0.0412\n $ residuals    : Named num [1:32] -2.01 -2.01 -2.35 2.43 3.94 ...\n $ effects      : Named num [1:32] -113.65 -28.44 -1.79 2.65 3.92 ...\n $ rank         : int 2\n $ fitted.values: Named num [1:32] 23 23 25.1 19 14.8 ...\n $ assign       : int [1:2] 0 1\n $ qr           :List of 5\n  ..$ qr   : num [1:32, 1:2] -5.657 0.177 0.177 0.177 0.177 ...\n  ..$ qraux: num [1:2] 1.18 1.09\n  ..$ pivot: int [1:2] 1 2\n  ..$ tol  : num 1e-07\n  ..$ rank : int 2\n $ df.residual  : int 30\n $ xlevels      : Named list()\n $ call         : language lm(formula = mpg ~ disp, data = mtcars)\n $ terms        :Classes 'terms', 'formula'  language mpg ~ disp\n $ model        :'data.frame':\t32 obs. of  2 variables:\n  ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n  ..$ disp: num [1:32] 160 160 108 258 360 ...\n```\n:::\n:::\n\n\n## S3 generics\n\n- In S3, methods (class-specific functions) are managed using **generic functions**\n\n::: {.cell}\n\n```{.r .cell-code}\nreg_model = lm(log(mpg) ~ log(disp), data = mtcars)\naov_model = aov(log(mpg) ~ log(disp), data = mtcars)\n\nclass(reg_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"lm\"\n```\n:::\n\n```{.r .cell-code}\nclass(aov_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"aov\" \"lm\" \n```\n:::\n\n```{.r .cell-code}\ninherits(aov_model, 'lm')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nprint(reg_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = log(mpg) ~ log(disp), data = mtcars)\n\nCoefficients:\n(Intercept)    log(disp)  \n     5.3810      -0.4586  \n```\n:::\n\n```{.r .cell-code}\nprint(aov_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCall:\n   aov(formula = log(mpg) ~ log(disp), data = mtcars)\n\nTerms:\n                log(disp) Residuals\nSum of Squares  2.2559626 0.4927736\nDeg. of Freedom         1        30\n\nResidual standard error: 0.1281631\nEstimated effects may be unbalanced\n```\n:::\n\n```{.r .cell-code}\nresiduals(aov_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Mazda RX4       Mazda RX4 Wag          Datsun 710      Hornet 4 Drive \n       -0.009136238        -0.009136238        -0.107135015         0.228829658 \n  Hornet Sportabout             Valiant          Duster 360           Merc 240D \n        0.246731745        -0.001408610        -0.021532242         0.101128004 \n           Merc 230            Merc 280           Merc 280C          Merc 450SE \n        0.014481527        -0.077467905        -0.153179727        -0.006685912 \n         Merc 450SL         Merc 450SLC  Cadillac Fleetwood Lincoln Continental \n        0.046739255        -0.082671818        -0.215771303        -0.227580582 \n  Chrysler Imperial            Fiat 128         Honda Civic      Toyota Corolla \n        0.098076936         0.099131472         0.017593403         0.097817784 \n      Toyota Corona    Dodge Challenger         AMC Javelin          Camaro Z28 \n       -0.117145641         0.002161632        -0.038029398        -0.106946015 \n   Pontiac Firebird           Fiat X1-9       Porsche 914-2        Lotus Europa \n        0.321433494        -0.070395535         0.073660971         0.122216133 \n     Ford Pantera L        Ferrari Dino       Maserati Bora          Volvo 142E \n        0.066608217        -0.118181538        -0.055822446        -0.118384067 \n```\n:::\n\n```{.r .cell-code}\nresiduals(reg_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Mazda RX4       Mazda RX4 Wag          Datsun 710      Hornet 4 Drive \n       -0.009136238        -0.009136238        -0.107135015         0.228829658 \n  Hornet Sportabout             Valiant          Duster 360           Merc 240D \n        0.246731745        -0.001408610        -0.021532242         0.101128004 \n           Merc 230            Merc 280           Merc 280C          Merc 450SE \n        0.014481527        -0.077467905        -0.153179727        -0.006685912 \n         Merc 450SL         Merc 450SLC  Cadillac Fleetwood Lincoln Continental \n        0.046739255        -0.082671818        -0.215771303        -0.227580582 \n  Chrysler Imperial            Fiat 128         Honda Civic      Toyota Corolla \n        0.098076936         0.099131472         0.017593403         0.097817784 \n      Toyota Corona    Dodge Challenger         AMC Javelin          Camaro Z28 \n       -0.117145641         0.002161632        -0.038029398        -0.106946015 \n   Pontiac Firebird           Fiat X1-9       Porsche 914-2        Lotus Europa \n        0.321433494        -0.070395535         0.073660971         0.122216133 \n     Ford Pantera L        Ferrari Dino       Maserati Bora          Volvo 142E \n        0.066608217        -0.118181538        -0.055822446        -0.118384067 \n```\n:::\n:::\n\n---\n\n\n- Both `aov_model` and `reg_model` inherit from `lm`\n- `print()` and `residuals()` are both generics\n    - (There can be) different versions of each function for different classes\n    - Different output for `print()`\n    - Same output for `residuals()`\n\n\n---\n\n- `print()` and `residuals()` are generics: \n- the call just passes us off to a class-specific function using `UseMethod()`\n\n::: {.cell}\n\n```{.r .cell-code}\nprint\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nUseMethod(\"print\")\n<bytecode: 0x7fd13513bbe0>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nresiduals\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (object, ...) \nUseMethod(\"residuals\")\n<bytecode: 0x7fd13740afd8>\n<environment: namespace:stats>\n```\n:::\n:::\n\n---\n\n\n- `sloop` package is is designed to figure out which specific function is called\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sloop)\n\ns3_dispatch(print(reg_model))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n=> print.lm\n * print.default\n```\n:::\n\n```{.r .cell-code}\ns3_dispatch(print(aov_model))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n=> print.aov\n * print.lm\n * print.default\n```\n:::\n:::\n\n---\n\nNote that the methods are hidden\n\n::: {.cell}\n\n```{.r .cell-code}\ntry(print.lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in try(print.lm) : object 'print.lm' not found\n```\n:::\n\n```{.r .cell-code}\ntry(stats::print.lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError : 'print.lm' is not an exported object from 'namespace:stats'\n```\n:::\n\n```{.r .cell-code}\nstats:::print.lm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, digits = max(3L, getOption(\"digits\") - 3L), ...) \n{\n    cat(\"\\nCall:\\n\", paste(deparse(x$call), sep = \"\\n\", collapse = \"\\n\"), \n        \"\\n\\n\", sep = \"\")\n    if (length(coef(x))) {\n        cat(\"Coefficients:\\n\")\n        print.default(format(coef(x), digits = digits), print.gap = 2L, \n            quote = FALSE)\n    }\n    else cat(\"No coefficients\\n\")\n    cat(\"\\n\")\n    invisible(x)\n}\n<bytecode: 0x7fd1425c25b8>\n<environment: namespace:stats>\n```\n:::\n\n```{.r .cell-code}\ns3_get_method(print.lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, digits = max(3L, getOption(\"digits\") - 3L), ...) \n{\n    cat(\"\\nCall:\\n\", paste(deparse(x$call), sep = \"\\n\", collapse = \"\\n\"), \n        \"\\n\\n\", sep = \"\")\n    if (length(coef(x))) {\n        cat(\"Coefficients:\\n\")\n        print.default(format(coef(x), digits = digits), print.gap = 2L, \n            quote = FALSE)\n    }\n    else cat(\"No coefficients\\n\")\n    cat(\"\\n\")\n    invisible(x)\n}\n<bytecode: 0x7fd1425c25b8>\n<environment: namespace:stats>\n```\n:::\n:::\n\n- *Use `s3_dispatch()` to explain why the two models have the same output for `residuals()`.*\n\n---\n\n\n- `sloop::s3_methods_generic()` lists all class-specific versions of generics\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns3_methods_generic('print')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 262 × 4\n   generic class   visible source             \n   <chr>   <chr>   <lgl>   <chr>              \n 1 print   acf     FALSE   registered S3method\n 2 print   AES     FALSE   registered S3method\n 3 print   anova   FALSE   registered S3method\n 4 print   aov     FALSE   registered S3method\n 5 print   aovlist FALSE   registered S3method\n 6 print   ar      FALSE   registered S3method\n 7 print   Arima   FALSE   registered S3method\n 8 print   arima0  FALSE   registered S3method\n 9 print   AsIs    TRUE    base               \n10 print   aspell  FALSE   registered S3method\n# … with 252 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n\n- And similarly for all generics defined for a given class\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns3_methods_class('lm')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 35 × 4\n   generic        class visible source             \n   <chr>          <chr> <lgl>   <chr>              \n 1 add1           lm    FALSE   registered S3method\n 2 alias          lm    FALSE   registered S3method\n 3 anova          lm    FALSE   registered S3method\n 4 case.names     lm    FALSE   registered S3method\n 5 confint        lm    TRUE    stats              \n 6 cooks.distance lm    FALSE   registered S3method\n 7 deviance       lm    FALSE   registered S3method\n 8 dfbeta         lm    FALSE   registered S3method\n 9 dfbetas        lm    FALSE   registered S3method\n10 drop1          lm    FALSE   registered S3method\n# … with 25 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n\n\n## Functional programming\n\n- board game as a series of functions? \n- regression models as a series of functions\n\n\n```{mermaid}\nflowchart LR\n  pre[\" \"] -- data --> extract\n  extract -- X --> QR[QR\\ndecomposition] -- \"Q, R\" --> combine\n  extract -- Y --> combine\n  combine -- \"Rβ = Q<sup>T</sup>Y\" --> backsolve\n  backsolve -- β --> post[\" \"]\n  style pre height:0px;\n  style post height:0px;\n```\n\n\n\n## Common features of functional programming\n\nFirst-class functions\n:  Functions can be used like any other data type, including as inputs to and outputs from other functions\n\nDeterminism\n:  Given a list of input values, a function always returns the same output value\n\nNo side effects\n:  A function doesn't have any effects other than returning its output\n\nImmutability\n:  Once a variable is assigned a value, that value cannot be changed\n\nThese features make it much easier to reason about how a functional program works. \n\n## Breaking R: Everything that happens is a function ##\n\n- This includes assignment\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo = 3\n`<-` <- function(x, y) x + y\nfoo <- 5\nfoo = 7\n```\n:::\n\n\n- And brackets\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`[` <- function(x, y) x * y\nbar = data.frame(x = rep(1, 15),\n                 y = rep(2, 15))\nbar['x']\nbar[2]\nbar[18]\n```\n:::\n\n\n## Actually-useful functional R:  Pipes (and the tidyverse)\n\n- Pipe syntax for function composition (`%>%` and `|>`)\n- Tidyverse functions are designed to work with pipes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n    filter(cyl > 4) %>% \n    lm(mpg ~ disp, data = .) %>% \n    summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = mpg ~ disp, data = .)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.4010 -1.5419 -0.5121  1.1408  4.9873 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 23.623520   1.463181  16.145 1.50e-12 ***\ndisp        -0.023527   0.004682  -5.025 7.52e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.118 on 19 degrees of freedom\nMultiple R-squared:  0.5706,\tAdjusted R-squared:  0.548 \nF-statistic: 25.25 on 1 and 19 DF,  p-value: 7.521e-05\n```\n:::\n:::\n\n\n- Using the new native pipes with the new native anonymous functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n    filter(cyl > 4) |>\n    {\\(d) lm(mpg ~ disp, data = d)}() |>\n    summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = mpg ~ disp, data = d)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.4010 -1.5419 -0.5121  1.1408  4.9873 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 23.623520   1.463181  16.145 1.50e-12 ***\ndisp        -0.023527   0.004682  -5.025 7.52e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.118 on 19 degrees of freedom\nMultiple R-squared:  0.5706,\tAdjusted R-squared:  0.548 \nF-statistic: 25.25 on 1 and 19 DF,  p-value: 7.521e-05\n```\n:::\n:::\n\n\n## Programming paradigms and data science\n\n- OOP is most useful for developers\n- Functional programming rules are really useful for data cleaning and analysis\n    - \"The analysis pipeline\"\n    - Reasoning about the state of our code\n    - Ensuring reproducibility\n\n\n<!--\n## Lab:  Purrr\n- palmerpenguins\n- broom\n- map() and list columns in dataframes\n- microethics? \n-->\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}