# Joins #

- The diversity data doesn't contain the `system` variable, or anything else to distinguish public vs. private vs. for-profit schools.  
- However, we can combine it with the tuition data, matching by school name.
- This is done using operations called *joins*.  

```{r, echo = FALSE, fig.show = 'hold', out.width = '45%', fig.cap = 'Join operations combine two dataframes based on one or more matching columns.  Different join operations keep different rows from the combination.  Sources: <https://data-lessons.github.io/gapminder-R/>; <https://notchained.hatenablog.com/entry/2015/01/03/160700>'}
knitr::include_graphics(file.path('images', '03-eda', 'join-rows.png'))
knitr::include_graphics(file.path('images', '03-eda', 'join-venn.png'))
```

- Suppose we're joining two dataframes, `left` and `right`
```{r}
left = tribble(
    ~animal, ~zoo,
    'aardvark', 'Sacramento', 
    'aardvark', 'San Diego',
    'chimpanzee', 'San Diego',
    'zebra', 'San Diego'
)
right = tribble(
    ~animal, ~food, 
    'aardvark', 'insects', 
    'chimpanzee', 'insects', 
    'chimpanzee', 'fruit', 
    'velociraptor', 'animals'
)
```


- *Left join*: keep all of the rows and columns from `left`; add columns from `right`
```{r}
left_join(left, right, by = 'animal')
```

- *Right join*: keep all of the rows and columns from `right`; add columns from `left`
```{r}
right_join(left, right, by = 'animal')
```

- *Full join*: keep all rows and columns from both `left` and `right`
```{r}
full_join(left, right, by = 'animal')
```

- *Inner join*: keep all columns, but only rows that match
```{r}
inner_join(left, right, by = 'animal')
```

- *Anti-join*: keep all columns from `left`, but only the rows that *don't* match
```{r}
anti_join(left, right, by = 'animal')
```

- Joins are powerful but can create hazards
    - *Missing values* from left, right, and full joins
        - In a left join, rows from `left` that don't match will have missing values in the columns from `right`
    - *Row counts* can be difficult to predict in advance
        - Rows will be copied if they match multiple times
    - *Column names* can be changed if they're repeated across dataframes but not used for matching

```{r}
inner_join(tuition_df, div_df, by = 'name') %>% 
    names()
```

- To manage these hazards
    - Use `anti_join()` to figure out where missing values will be
    - Use `select()` with `distinct()` to check for unexpected duplications
    - Use `names()` to check column names
    
```{r}
## Schools in tuition_df that will be missing after we join w/ div_df
anti_join(tuition_df, div_df, by = 'name') %>% 
    pull(name)

## Because div_df isn't filtered down to 2-year schools, it's okay if a lot of its schools are left out
anti_join(div_df, tuition_df, by = 'name') %>% 
    nrow()

## Checking duplications
comb_df_draft = inner_join(tuition_df, div_df, by = 'name')
nrow(comb_df_draft)
nrow(distinct(comb_df_draft))

## 135 schools in tuition_df, minus 20 rows not matched
comb_df_draft %>% 
    select(name) %>% 
    distinct() %>% 
    nrow()

## We should have one row in comb_df_draft for each school-category combination
comb_df_draft %>% 
    select(name, category) %>% 
    distinct() %>% 
    nrow()

## Check column names
names(comb_df_draft)
```

After all that, we can create some plots for demographic categories against school system and in-state tuition. 