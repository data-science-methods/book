# Functional Programming and Data Science #

## Reading ##

- Introductions to parts II and III of @WickhamAdvanced2014
- @ChambersObjectOrientedProgrammingFunctional2014

## Dependencies ##

```{r, eval = FALSE}
install.packages('sloop')
```

## Programming paradigms ##
- *Procedural* or *imperative*:  Software is a series of instructions ("procedures"), which the computer carries out in order.  Special instructions (if-then, loops) are used to change the order based on inputs or other conditions.  
    - Examples: FORTRAN, BASIC, C, calculator

- *Object-oriented*:  Software is made up of objects, which have properties ("attributes," including other objects) and do things ("methods").  

- *Functional*:  Software is made up of functions, which are run sequentially on the inputs

- R is both object-oriented *and* functional
    - Object-oriented:  Everything that exists is an object
    - Functional:  Everything that happens is a function call
    
## Object-oriented R:  S3

- board game as OOP
- regression models as OOP


### S3 is not the OOP you're used to ###

```{python, eval = FALSE}
## <https://vegibit.com/python-class-examples/>
class Vehicle:
    def __init__(self, brand, model, type):
        self.brand = brand
        self.model = model
        self.type = type
        self.gas_tank_size = 14
        self.fuel_level = 0

    def fuel_up(self):
        self.fuel_level = self.gas_tank_size
        print('Gas tank is now full.')

    def drive(self):
        if self.fuel_level > 0:
            print(f'The {self.model} is now driving.')
            self.fuel_level -= 1
        else:
            print(f'The {self.model} is out of gas!')
        
class ElectricVehicle(Vehicle):
    def __init__(self, brand, model, type):
        super().__init__(brand, model, type)
        self.battery_size = 85
        self.charge_level = 0

    def fuel_up(self):
        print('This vehicle has no fuel tank!')
        
dhCar = Vehicle('Honda', 'Fit', 'Hatchback')
type(dhCar)
dhCar.gas_tank_size = 10
dhCar.fuel_up()
dhCar.drive()
```

S3 classes can be changed on the fly, with no attempt to validate any assumptions. 

```{r}
dh_car = list(brand = 'Honda', model = 'Fit', type = 'Hatchback')
class(dh_car)
class(dh_car) = c('vehicle', class(dh_car))
class(dh_car)
inherits(dh_car, 'vehicle')
```
```{r}
model = lm(log(mpg) ~ log(disp), data = mtcars)
class(model)
print(model)
class(model) = 'Date'
class(model)
try(print(model))
```

- Wickham discusses good practices to reduce this chaos in S3
    - write constructor, validator, and helper functions
- S4 and R6 provide more conventional OOP structure

- Instead of "methods are defined within classes," S3 uses **generic functions**

```{r}
reg_model = lm(log(mpg) ~ log(disp), data = mtcars)
aov_model = aov(log(mpg) ~ log(disp), data = mtcars)

class(reg_model)
class(aov_model)
inherits(aov_model, 'lm')

print(reg_model)
print(aov_model)

residuals(aov_model)
residuals(reg_model)
```

- Both `aov_model` and `reg_model` inherit `lm`
- Different output for `print()`
- Same output for `residuals()`

```{r}
library(sloop)
## print() is a generic; the call just passes us off using UseMethod()
print
s3_dispatch(print(reg_model))
s3_dispatch(print(aov_model))

## The class-specific methods are hidden
try(print.lm)
s3_get_method(print.lm)
# stats:::print.lm
s3_get_method(print.aov)
# stats:::print.aov
```

- *Use `s3_dispatch()` to explain why the two models have the same output for `residuals()`.*

```{r}
## Finding all class-specific versions of some generics
s3_methods_generic('print')
s3_methods_generic('residuals')
```

## Functional R

- board game as a series of functions
- regression models as a series of functions
- breaking R

```
foo = 3
`<-` <- function(x, y) x + y
foo <- 5
foo = 7
```

```
`[` <- function(x, y) x * y
bar = data.frame(x = rep(1, 15),
                 y = rep(2, 15))
bar['x']
bar[2]
bar[18]
```


## Actually-useful functional R:  Pipes (and the tidyverse)

- Pipe syntax (`%>%` and `|>`)
- Tidyverse functions

```{r}
library(dplyr)
mtcars %>%
    filter(cyl > 4) %>% 
    lm(mpg ~ disp, data = .) %>% 
    summary()
```

- *Immutability*:  Once the value is assigned to a variable, that value cannot be changed
- *No side effects*:  Functions don't change anything; they only return a value

## Programming paradigms and data science

- OOP is most useful for developers
- Immutability and no side effects are really useful for data cleaning and analysis
    - "The analysis pipeline"
    - Reasoning about the state of our code
    - Ensuring reproducibility


## Lab:  Purrr
- palmerpenguins
- broom
- map() and list columns in dataframes
- microethics? 


